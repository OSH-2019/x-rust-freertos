// This file is created by Fan Jinhao.
// This file is an interface to the C "port.c", "portmacro.h", "portable.h".
// These definitions are generated automatically and may be different on a different machine.

/* automatically generated by rust-bindgen */

pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portUSING_MPU_WRAPPERS: u32 = 0;

pub type TaskFunction_t = *mut ::std::os::raw::c_void;
// TODO: Fn() ?
pub type StackType_t = usize;
pub type BaseType_t = ::std::os::raw::c_long;
pub type UBaseType_t = ::std::os::raw::c_ulong;
pub type TickType_t = u32;
extern "C" {
    #[link_name = "\u{1}_vPortYieldFromISR"]
    pub fn vPortYieldFromISR();
}
extern "C" {
    #[link_name = "\u{1}_vPortYield"]
    pub fn vPortYield();
}
extern "C" {
    #[link_name = "\u{1}_xPortSetInterruptMask"]
    pub fn xPortSetInterruptMask() -> BaseType_t;
}
extern "C" {
    #[link_name = "\u{1}_vPortClearInterruptMask"]
    pub fn vPortClearInterruptMask(xMask: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_vPortDisableInterrupts"]
    pub fn vPortDisableInterrupts();
}
extern "C" {
    #[link_name = "\u{1}_vPortEnableInterrupts"]
    pub fn vPortEnableInterrupts();
}
extern "C" {
    #[link_name = "\u{1}_vPortEnterCritical"]
    pub fn vPortEnterCritical();
}
extern "C" {
    #[link_name = "\u{1}_vPortExitCritical"]
    pub fn vPortExitCritical();
}
extern "C" {
    #[link_name = "\u{1}_vPortForciblyEndThread"]
    pub fn vPortForciblyEndThread(pxTaskToDelete: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_vPortAddTaskHandle"]
    pub fn vPortAddTaskHandle(pxTaskHandle: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_vPortFindTicksPerSecond"]
    pub fn vPortFindTicksPerSecond();
}
extern "C" {
    #[link_name = "\u{1}_ulPortGetTimerValue"]
    pub fn ulPortGetTimerValue() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_pxPortInitialiseStack"]
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::std::os::raw::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HeapRegion() {
    assert_eq!(
        ::std::mem::size_of::<HeapRegion>(),
        16usize,
        concat!("Size of: ", stringify!(HeapRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(HeapRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).pucStartAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(pucStartAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).xSizeInBytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(xSizeInBytes)
        )
    );
}
pub type HeapRegion_t = HeapRegion;
extern "C" {
    #[link_name = "\u{1}_vPortDefineHeapRegions"]
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
    #[link_name = "\u{1}_pvPortMalloc"]
    pub fn pvPortMalloc(xSize: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_vPortFree"]
    pub fn vPortFree(pv: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_vPortInitialiseBlocks"]
    pub fn vPortInitialiseBlocks();
}
extern "C" {
    #[link_name = "\u{1}_xPortGetFreeHeapSize"]
    pub fn xPortGetFreeHeapSize() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_xPortGetMinimumEverFreeHeapSize"]
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_xPortStartScheduler"]
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    #[link_name = "\u{1}_vPortEndScheduler"]
    pub fn vPortEndScheduler();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
