// Depress some warnings caused by our C bindings.
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#![feature(fnbox)]

#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
extern crate simplelog;

mod bindings; // This file is generated by bindgen and doesn't show up in the git repo.
mod port;
mod config;
mod projdefs;
mod trace;
mod ffi;
mod list;
mod task_global;
pub mod task_control;
// mod task_api;
pub mod kernel;
// mod queue;
// mod queue_h;

#[cfg(test)]
mod tests {
    use super::*;

    /*
    // Note! This test SHOULD FAIL, showing something like this:
    // test tests::test_vPortYield ... error: process didn't exit successfully: `/rust_freertos/target/debug/deps/rust_freertos-f3432ee83a2dce9a` (signal: 11, SIGSEGV: invalid memory reference)
    #[test]
    fn test_portYIELD() {
        portYIELD!()
    }
    */

    /*
    // Note! This test SHOULD FAIL as well.
    // BUT on my Mac it just doesn't stop running. Weird.
    use port;
    #[test]
    fn test_port_start_scheduler() {
        port::port_start_scheduler();
    }
    */
    use std::sync::Arc;
    use simplelog::*;
    use std::fs::*;
    #[test]
    fn test_basics() {
        // The logger may cause mutex deadlocks on the log file.
        WriteLogger::init(LevelFilter::Trace, Config::default(), File::create("debug.log").unwrap()).unwrap();
        task_global::init();

        let m = Arc::new(String::from("Wow, We made it!"));
        let _main_task = task_control::TCB::new()
                            .name("main")
                            .priority(1)
                            .initialise(move || {
                                // let v = Arc::clone(&m);
                                loop {
                                    // println!("Main task running.");
                                    // kernel::task_end_scheduler();
                                }
                            });

        let _other_task = task_control::TCB::new()
                            .name("other")
                            .priority(1)
                            .initialise(move || {
                                // let v = Arc::clone(&m);
                                loop {
                                    // println!("other task running.");
                                }
                            });
        kernel::task_start_scheduler();
        println!("Exit");
    }
}
