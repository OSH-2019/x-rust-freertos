<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `src/task_control.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>task_control.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rust_freertos/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">kernel</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">list</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">list</span>::<span class="ident">ItemLink</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">list</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">port</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">projdefs</span>::<span class="ident">FreeRtosError</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">task_global</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">boxed</span>::<span class="ident">FnBox</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::{<span class="ident">Arc</span>, <span class="ident">RwLock</span>, <span class="ident">Weak</span>};

<span class="comment">/* Task states returned by eTaskGetState. */</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">u8</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">task_state</span> {
    <span class="ident">running</span> <span class="op">=</span> <span class="number">0</span>,
    <span class="ident">ready</span> <span class="op">=</span> <span class="number">1</span>,
    <span class="ident">blocked</span> <span class="op">=</span> <span class="number">2</span>,
    <span class="ident">suspended</span> <span class="op">=</span> <span class="number">3</span>,
    <span class="ident">deleted</span> <span class="op">=</span> <span class="number">4</span>,
}

<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">updated_top_priority</span> {
    <span class="ident">Updated</span>,
    <span class="ident">Notupdated</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">task_control_block</span> {
    <span class="comment">//* basic information</span>
    <span class="ident">state_list_item</span>: <span class="ident">ItemLink</span>,
    <span class="ident">event_list_item</span>: <span class="ident">ItemLink</span>,
    <span class="ident">task_priority</span>: <span class="ident">UBaseType</span>,
    <span class="ident">task_stacksize</span>: <span class="ident">UBaseType</span>,
    <span class="ident">task_name</span>: <span class="ident">String</span>,
    <span class="comment">// `stack_pos` is StackType because raw pointer can&#39;t be sent between threads safely.</span>
    <span class="ident">stack_pos</span>: <span class="ident">StackType</span>,

    <span class="comment">//* end of stack</span>
    <span class="comment">// #[cfg(portStack_GROWTH)]{}</span>
    <span class="comment">// end_of_stack: *mut StackType,</span>

    <span class="comment">//* nesting</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;portCRITICAL_NESTING_IN_TCB&quot;</span>)]</span>
    <span class="ident">critical_nesting</span>: <span class="ident">UBaseType</span>,

    <span class="comment">//* reverse priority</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="ident">base_priority</span>: <span class="ident">UBaseType</span>,
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="ident">mutexes_held</span>: <span class="ident">UBaseType</span>,

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
    <span class="ident">runtime_counter</span>: <span class="ident">TickType</span>,

    <span class="comment">//* notify information</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TASK_NOTIFICATIONS&quot;</span>)]</span>
    <span class="ident">notified_value</span>: <span class="ident">u32</span>,
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TASK_NOTIFICATIONS&quot;</span>)]</span>
    <span class="ident">notify_state</span>: <span class="ident">u8</span>,
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
    <span class="ident">delay_aborted</span>: <span class="ident">bool</span>,
}

<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">TCB</span> <span class="op">=</span> <span class="ident">task_control_block</span>;
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">Task</span> <span class="op">=</span> <span class="ident">task_control_block</span>;
<span class="kw">impl</span> <span class="ident">task_control_block</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">task_control_block</span> {
            <span class="ident">state_list_item</span>: <span class="ident">Default</span>::<span class="ident">default</span>(),
            <span class="ident">event_list_item</span>: <span class="ident">Default</span>::<span class="ident">default</span>(),
            <span class="ident">task_priority</span>: <span class="number">1</span>,
            <span class="ident">task_stacksize</span>: <span class="macro">configMINIMAL_STACK_SIZE</span><span class="macro">!</span>(),
            <span class="ident">task_name</span>: <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;Unnamed&quot;</span>),
            <span class="ident">stack_pos</span>: <span class="number">0</span>,

            <span class="comment">//* nesting</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;portCRITICAL_NESTING_IN_TCB&quot;</span>)]</span>
            <span class="ident">critical_nesting</span>: <span class="number">0</span>,

            <span class="comment">//* reverse priority</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
            <span class="ident">base_priority</span>: <span class="number">0</span>,
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
            <span class="ident">mutexes_held</span>: <span class="number">0</span>,

            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
            <span class="ident">runtime_counter</span>: <span class="number">0</span>,

            <span class="comment">//* notify information</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TASK_NOTIFICATIONS&quot;</span>)]</span>
            <span class="ident">notified_value</span>: <span class="number">0</span>,
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TASK_NOTIFICATIONS&quot;</span>)]</span>
            <span class="ident">notify_state</span>: <span class="number">0</span>,
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
            <span class="ident">delay_aborted</span>: <span class="bool-val">false</span>,
        }
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">task_name</span> <span class="op">=</span> <span class="ident">name</span>.<span class="ident">to_owned</span>().<span class="ident">to_string</span>();
        <span class="self">self</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">stacksize</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">stacksize</span>: <span class="ident">UBaseType</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">task_stacksize</span> <span class="op">=</span> <span class="ident">stacksize</span>;
        <span class="self">self</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">priority</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">priority</span>: <span class="ident">UBaseType</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="kw">if</span> <span class="ident">priority</span> <span class="op">&gt;=</span> <span class="macro">configMAX_PRIORITIES</span><span class="macro">!</span>() {
            <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;Specified priority larger than system maximum priority, will be reduced.&quot;</span>);
            <span class="macro">info</span><span class="macro">!</span>(
                <span class="string">&quot;MAX_PRIORITY is {}, but got {}&quot;</span>,
                <span class="macro">configMAX_PRIORITIES</span><span class="macro">!</span>() <span class="op">-</span> <span class="number">1</span>,
                <span class="ident">priority</span>
            );
            <span class="self">self</span>.<span class="ident">task_priority</span> <span class="op">=</span> <span class="macro">configMAX_PRIORITIES</span><span class="macro">!</span>() <span class="op">-</span> <span class="number">1</span>;
        } <span class="kw">else</span> {
            <span class="self">self</span>.<span class="ident">task_priority</span> <span class="op">=</span> <span class="ident">priority</span>;
        }
        <span class="self">self</span>
    }

    <span class="doccomment">/// * Descrpition:</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  Create a new task and add it to the list of tasks that are ready to run.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  Internally, within the FreeRTOS implementation, tasks use two blocks of</span>
    <span class="doccomment">///  memory.  The first block is used to hold the task&#39;s data structures.  The</span>
    <span class="doccomment">///  second block is used by the task as its stack.  If a task is created using</span>
    <span class="doccomment">///  xTaskCreate() then both blocks of memory are automatically dynamically</span>
    <span class="doccomment">///  allocated inside the xTaskCreate() function.  (see</span>
    <span class="doccomment">///  http://www.freertos.org/a00111.html).  If a task is created using</span>
    <span class="doccomment">///  xTaskCreateStatic() then the application writer must provide the required</span>
    <span class="doccomment">///  memory.  xTaskCreateStatic() therefore allows a task to be created without</span>
    <span class="doccomment">///  using any dynamic memory allocation.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  See xTaskCreateStatic() for a version that does not use any dynamic memory</span>
    <span class="doccomment">///  allocation.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  xTaskCreate() can only be used to create a task that has unrestricted</span>
    <span class="doccomment">///  access to the entire microcontroller memory map.  Systems that include MPU</span>
    <span class="doccomment">///  support can alternatively create an MPU constrained task using</span>
    <span class="doccomment">///  xTaskCreateRestricted().</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// * Implemented by: Fan Jinhao</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///  @param pvTaskCode Pointer to the task entry function.  Tasks</span>
    <span class="doccomment">///  must be implemented to never return (i.e. continuous loop).</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  @param pcName A descriptive name for the task.  This is mainly used to</span>
    <span class="doccomment">///  facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default</span>
    <span class="doccomment">///  is 16.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  @param usStackDepth The size of the task stack specified as the number of</span>
    <span class="doccomment">///  variables the stack can hold - not the number of bytes.  For example, if</span>
    <span class="doccomment">///  the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes</span>
    <span class="doccomment">///  will be allocated for stack storage.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  @param pvParameters Pointer that will be used as the parameter for the task</span>
    <span class="doccomment">///  being created.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  @param uxPriority The priority at which the task should run.  Systems that</span>
    <span class="doccomment">///  include MPU support can optionally create tasks in a privileged (system)</span>
    <span class="doccomment">///  mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For</span>
    <span class="doccomment">///  example, to create a privileged task at priority 2 the uxPriority parameter</span>
    <span class="doccomment">///  should be set to ( 2 | portPRIVILEGE_BIT ).</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">///  @param pvCreatedTask Used to pass back a handle by which the created task</span>
    <span class="doccomment">///  can be referenced.</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// * Return:</span>
    <span class="doccomment">///  @return pdPASS if the task was successfully created and added to a ready</span>
    <span class="doccomment">///  list, otherwise an error code defined in the file projdefs.h</span>
    <span class="doccomment">/// </span>
    <span class="doccomment">/// </span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">initialise</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">func</span>: <span class="ident">F</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">TaskHandle</span>, <span class="ident">FreeRtosError</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">F</span>: <span class="ident">FnOnce</span>() <span class="op">-&gt;</span> () <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="lifetime">&#39;static</span>,
    {
        <span class="kw">let</span> <span class="ident">size_of_stacktype</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">StackType</span><span class="op">&gt;</span>();
        <span class="kw">let</span> <span class="ident">stacksize_as_bytes</span> <span class="op">=</span> <span class="ident">size_of_stacktype</span> <span class="op">*</span> <span class="self">self</span>.<span class="ident">task_stacksize</span> <span class="kw">as</span> <span class="ident">usize</span>;
        <span class="macro">trace</span><span class="macro">!</span>(
            <span class="string">&quot;Initialising Task: {}, stack size: {} bytes&quot;</span>,
            <span class="self">self</span>.<span class="ident">task_name</span>,
            <span class="ident">stacksize_as_bytes</span>
        );

        <span class="comment">// Return `Err` if malloc fails.</span>
        <span class="kw">let</span> <span class="ident">px_stack</span> <span class="op">=</span> <span class="ident">port</span>::<span class="ident">port_malloc</span>(<span class="ident">stacksize_as_bytes</span>)<span class="question-mark">?</span>;

        <span class="comment">// A trick here. By changing raw pointer `px_stack` to StackType,</span>
        <span class="comment">// avoid using unsafe `*mut` as a struct field.</span>
        <span class="comment">// We don&#39;t lost any information here because raw pointers are actually addresses,</span>
        <span class="comment">// which can be stored as plain numbers.</span>
        <span class="self">self</span>.<span class="ident">stack_pos</span> <span class="op">=</span> <span class="ident">px_stack</span> <span class="kw">as</span> <span class="ident">StackType</span>;
        <span class="macro">trace</span><span class="macro">!</span>(
            <span class="string">&quot;stack_pos for task {} is {}&quot;</span>,
            <span class="self">self</span>.<span class="ident">task_name</span>,
            <span class="self">self</span>.<span class="ident">stack_pos</span>
        );

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">top_of_stack</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">stack_pos</span> <span class="op">+</span> <span class="self">self</span>.<span class="ident">task_stacksize</span> <span class="kw">as</span> <span class="ident">StackType</span> <span class="op">-</span> <span class="number">1</span>;
        <span class="ident">top_of_stack</span> <span class="op">=</span> <span class="ident">top_of_stack</span> <span class="op">&amp;</span> <span class="ident">portBYTE_ALIGNMENT_MASK</span> <span class="kw">as</span> <span class="ident">StackType</span>;

        <span class="kw">let</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">func</span>) <span class="kw">as</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">FnBox</span>()<span class="op">&gt;</span>); <span class="comment">// Pass task function as a parameter.</span>
        <span class="kw">let</span> <span class="ident">param_ptr</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">f</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>; <span class="comment">// Convert to raw pointer.</span>
        <span class="macro">trace</span><span class="macro">!</span>(
            <span class="string">&quot;Function ptr of {} is at {:X}&quot;</span>,
            <span class="self">self</span>.<span class="ident">get_name</span>(),
            <span class="ident">param_ptr</span> <span class="kw">as</span> <span class="ident">u64</span>
        );

        <span class="comment">/* We use a wrapper function to call the task closure,
         * this is how freertos.rs approaches this problem, and is explained here:
         * https://stackoverflow.com/questions/32270030/how-do-i-convert-a-rust-closure-to-a-c-style-callback
         */</span>
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span>
            <span class="ident">port</span>::<span class="ident">port_initialise_stack</span>(<span class="ident">top_of_stack</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>, <span class="prelude-val">Some</span>(<span class="ident">run_wrapper</span>), <span class="ident">param_ptr</span>);
        <span class="kw">match</span> <span class="ident">result</span> {
            <span class="prelude-val">Ok</span>(<span class="kw">_</span>) <span class="op">=&gt;</span> {
                <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Stack initialisation succeeded&quot;</span>);
                <span class="comment">/* We MUST forget `f`, otherwise it will be freed at the end of this function.
                 * But we need to call `f` later in `run_wrapper`, which will lead to
                 * some unexpected behavior.
                 */</span>
                <span class="ident">mem</span>::<span class="ident">forget</span>(<span class="ident">f</span>);
            }
            <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>),
        }

        <span class="comment">/* Do a bunch of conditional initialisations. */</span>
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">mutexes_held</span> <span class="op">=</span> <span class="number">0</span>;
            <span class="self">self</span>.<span class="ident">base_priority</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">task_priority</span>;
        }

        <span class="comment">/* These list items were already initialised when `self` was created.
        list_initialise_item! (self.state_list_item);
        list_initialise_item! (self.event_list_item);
        */</span>

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;portCRITICAL_NESTING_IN_TCB&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">critical_nesting</span> <span class="op">=</span> <span class="number">0</span>;
        }

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">runtime_counter</span> <span class="op">=</span> <span class="number">0</span>;
        }

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;config_USE_TASK_NOTIFICATIONS&quot;</span>)]</span>
        {
            <span class="self">self</span>.<span class="ident">notify_state</span> <span class="op">=</span> <span class="ident">taskNOT_WAITING_NOTIFICATION</span>;
            <span class="self">self</span>.<span class="ident">notified_value</span> <span class="op">=</span> <span class="number">0</span>;
        }

        <span class="comment">// Create task handle.</span>
        <span class="kw">let</span> <span class="ident">sp</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">stack_pos</span>;
        <span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="ident">TaskHandle</span>(<span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">RwLock</span>::<span class="ident">new</span>(<span class="self">self</span>)));
        <span class="comment">// TODO: Change type of list_items.</span>
        <span class="kw">let</span> <span class="ident">state_list_item</span> <span class="op">=</span> <span class="ident">handle</span>.<span class="ident">get_state_list_item</span>();
        <span class="kw">let</span> <span class="ident">event_list_item</span> <span class="op">=</span> <span class="ident">handle</span>.<span class="ident">get_event_list_item</span>();
        <span class="ident">list</span>::<span class="ident">set_list_item_owner</span>(<span class="kw-2">&amp;</span><span class="ident">state_list_item</span>, <span class="ident">handle</span>.<span class="ident">clone</span>());
        <span class="ident">list</span>::<span class="ident">set_list_item_owner</span>(<span class="kw-2">&amp;</span><span class="ident">event_list_item</span>, <span class="ident">handle</span>.<span class="ident">clone</span>());
        <span class="kw">let</span> <span class="ident">item_value</span> <span class="op">=</span> (<span class="macro">configMAX_PRIORITIES</span><span class="macro">!</span>() <span class="op">-</span> <span class="ident">handle</span>.<span class="ident">get_priority</span>()) <span class="kw">as</span> <span class="ident">TickType</span>;
        <span class="ident">list</span>::<span class="ident">set_list_item_value</span>(<span class="kw-2">&amp;</span><span class="ident">state_list_item</span>, <span class="ident">item_value</span>);

        <span class="ident">handle</span>.<span class="ident">add_new_task_to_ready_list</span>()<span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(<span class="ident">handle</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_state_list_item</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ItemLink</span> {
        <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">state_list_item</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_event_list_item</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ItemLink</span> {
        <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">event_list_item</span>)
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_priority</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="self">self</span>.<span class="ident">task_priority</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_priority</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">new_priority</span>: <span class="ident">UBaseType</span>) {
        <span class="self">self</span>.<span class="ident">task_priority</span> <span class="op">=</span> <span class="ident">new_priority</span>;
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="self">self</span>.<span class="ident">task_name</span>.<span class="ident">clone</span>()
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_run_time</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">TickType</span> {
        <span class="self">self</span>.<span class="ident">runtime_counter</span>
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_run_time</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">next_val</span>: <span class="ident">TickType</span>) <span class="op">-&gt;</span> <span class="ident">TickType</span> {
        <span class="kw">let</span> <span class="ident">prev_val</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">runtime_counter</span>;
        <span class="self">self</span>.<span class="ident">runtime_counter</span> <span class="op">=</span> <span class="ident">next_val</span>;
        <span class="ident">prev_val</span>
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_delay_aborted</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">delay_aborted</span>
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_delay_aborted</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">next_val</span>: <span class="ident">bool</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="kw">let</span> <span class="ident">prev_val</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">delay_aborted</span>;
        <span class="self">self</span>.<span class="ident">delay_aborted</span> <span class="op">=</span> <span class="ident">next_val</span>;
        <span class="ident">prev_val</span>
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_mutex_held_count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="self">self</span>.<span class="ident">mutexes_held</span>
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_mutex_held_count</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">new_count</span>: <span class="ident">UBaseType</span>) {
        <span class="self">self</span>.<span class="ident">mutexes_held</span> <span class="op">=</span> <span class="ident">new_count</span>;
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_base_priority</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="self">self</span>.<span class="ident">base_priority</span>
    }
}

<span class="kw">impl</span> <span class="ident">PartialEq</span> <span class="kw">for</span> <span class="ident">TCB</span> {
    <span class="kw">fn</span> <span class="ident">eq</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">other</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">stack_pos</span> <span class="op">==</span> <span class="ident">other</span>.<span class="ident">stack_pos</span>
    }
}

<span class="comment">/* Task call wrapper function. */</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">run_wrapper</span>(<span class="ident">func_to_run</span>: <span class="ident">CVoidPointer</span>) {
    <span class="macro">info</span><span class="macro">!</span>(
        <span class="string">&quot;Run_wrapper: The function is at position: {:X}&quot;</span>,
        <span class="ident">func_to_run</span> <span class="kw">as</span> <span class="ident">u64</span>
    );
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">func_to_run</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">from_raw</span>(<span class="ident">func_to_run</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">FnBox</span>() <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>);
        <span class="ident">func_to_run</span>();
        <span class="comment">// TODO: Delete this wrapper task.</span>
    }
}

<span class="comment">// * Record the Highest ready priority</span>
<span class="comment">// * Usage:</span>
<span class="comment">// * Input: num</span>
<span class="comment">// * Output: None</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">record_ready_priority</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">priority</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {{
        <span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">priority</span> <span class="op">&gt;</span> <span class="macro">get_top_ready_priority</span><span class="macro">!</span>() {
            <span class="macro">set_top_ready_priority</span><span class="macro">!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">priority</span>);
        }
    }};
}

<span class="comment">/*
pub fn initialize_task_list () {
    for priority in (0..configMAX_PRIORITIES-1)	{
        list_initialise! ( READY_TASK_LIST [priority] );
    }

    list_initialise!( DELAY_TASK_LIST1 );
    list_initialise!( DELAY_TASK_LIST2 );
    list_initialise!( PENDING_READY_LIST );

    {
        #![cfg(INCLUDE_vTaskDelete)]
        list_initialise!( TASK_WATCHING_TERMINATION );
    }

    {
        #![cfg(INCLUDE_vTaskSuspend)]
        list_initialise!( SUSPEND_TASK_LIST );
    }

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
       using list2. */
    DELAY_TASK_LIST = &amp;DELAY_TASK_LIST1;
    OVERFLOW_DELAYED_TASK_LIST = &amp;DELAY_TASK_LIST2;
}
*/</span>

<span class="doccomment">/// * Descrpition:</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  Type by which tasks are referenced.  For example, a call to xTaskCreate</span>
<span class="doccomment">///  returns (via a pointer parameter) an TaskHandle_t variable that can then</span>
<span class="doccomment">///  be used as a parameter to vTaskDelete to delete the task.</span>
<span class="doccomment">///  Since multiple `TaskHandle`s may refer to and own a same TCB at a time,</span>
<span class="doccomment">///  we wrapped TCB within a `tuple struct` using `Arc&lt;RwLock&lt;_&gt;&gt;`</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Implemented by: Fan Jinhao</span>
<span class="doccomment">/// </span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">TaskHandle</span>(<span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">TCB</span><span class="op">&gt;&gt;</span>);

<span class="kw">impl</span> <span class="ident">PartialEq</span> <span class="kw">for</span> <span class="ident">TaskHandle</span> {
    <span class="kw">fn</span> <span class="ident">eq</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">other</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="kw-2">*</span><span class="self">self</span>.<span class="number">0</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>() <span class="op">==</span> <span class="kw-2">*</span><span class="ident">other</span>.<span class="number">0</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>()
    }
}

<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">Weak</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">TCB</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">TaskHandle</span> {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">weak_link</span>: <span class="ident">Weak</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">TCB</span><span class="op">&gt;&gt;</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">TaskHandle</span>(
            <span class="ident">weak_link</span>
                .<span class="ident">upgrade</span>()
                .<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Owner is not set&quot;</span>)),
        )
    }
}

<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">TaskHandle</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Weak</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">TCB</span><span class="op">&gt;&gt;</span> {
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">task</span>: <span class="ident">TaskHandle</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">Arc</span>::<span class="ident">downgrade</span>(<span class="kw-2">&amp;</span><span class="ident">task</span>.<span class="number">0</span>)
    }
}

<span class="kw">impl</span> <span class="ident">TaskHandle</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_arc</span>(<span class="ident">arc</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">TCB</span><span class="op">&gt;&gt;</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="ident">TaskHandle</span>(<span class="ident">arc</span>)
    }

    <span class="doccomment">/// # Description:</span>
    <span class="doccomment">/// Construct a TaskHandle with a TCB. */</span>
    <span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
    <span class="doccomment">/// * C implementation:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments</span>
    <span class="doccomment">/// * `tcb`: The TCB that we want to get TaskHandle from.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Return</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The created TaskHandle.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">tcb</span>: <span class="ident">TCB</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="comment">// TODO: Implement From.</span>
        <span class="ident">TaskHandle</span>(<span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">RwLock</span>::<span class="ident">new</span>(<span class="ident">tcb</span>)))
    }

    <span class="comment">/* This function is for use in FFI. */</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_raw</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ffi</span>::<span class="ident">xTaskHandle</span> {
        <span class="ident">Arc</span>::<span class="ident">into_raw</span>(<span class="self">self</span>.<span class="number">0</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_priority</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="comment">/* Get the priority of a task.
         * Since this method is so frequently used, I used a funtion to do it.
         */</span>
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>().<span class="ident">get_priority</span>()
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_priority</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">new_priority</span>: <span class="ident">UBaseType</span>) {
        <span class="macro">get_tcb_from_handle_mut</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">set_priority</span>(<span class="ident">new_priority</span>);
    }

    <span class="doccomment">/// # Description:</span>
    <span class="doccomment">/// Place the task represented by pxTCB into the appropriate ready list for</span>
    <span class="doccomment">/// the task.  It is inserted at the end of the list.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
    <span class="doccomment">/// * C implementation:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Return</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// TODO</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_task_to_ready_list</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">FreeRtosError</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">unwrapped_tcb</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>);
        <span class="kw">let</span> <span class="ident">priority</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">get_priority</span>();

        <span class="macro">traceMOVED_TASK_TO_READY_STATE</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>);
        <span class="macro">record_ready_priority</span><span class="macro">!</span>(<span class="ident">priority</span>);

        <span class="comment">// let list_to_insert = (*READY_TASK_LISTS).write().unwrap();</span>
        <span class="comment">/* let list_to_insert = match list_to_insert {
            Ok(lists) =&gt; lists[unwrapped_tcb.task_priority as usize],
            Err(_) =&gt; {
                warn!(&quot;List was locked, read failed&quot;);
                return Err(FreeRtosError::DeadLocked);
            }
        };
        */</span>
        <span class="comment">// TODO: This line is WRONG! (just for test)</span>
        <span class="comment">// set_list_item_container!(unwrapped_tcb.state_list_item, list::ListName::READY_TASK_LISTS_1);</span>
        <span class="ident">list</span>::<span class="ident">list_insert_end</span>(
            <span class="kw-2">&amp;</span><span class="ident">READY_TASK_LISTS</span>[<span class="ident">priority</span> <span class="kw">as</span> <span class="ident">usize</span>],
            <span class="ident">Arc</span>::<span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>.<span class="ident">state_list_item</span>),
        );
        <span class="macro">tracePOST_MOVED_TASK_TO_READY_STATE</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>);
        <span class="prelude-val">Ok</span>(())
    }

    <span class="doccomment">/// # Description:</span>
    <span class="doccomment">/// Called after a new task has been created and initialised to place the task</span>
    <span class="doccomment">/// under the control of the scheduler.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
    <span class="doccomment">/// * C implementation:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Return</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// TODO</span>
    <span class="kw">fn</span> <span class="ident">add_new_task_to_ready_list</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">FreeRtosError</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">unwrapped_tcb</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>);

        <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
        {
            <span class="comment">// We don&#39;t need to initialise task lists any more.</span>
            <span class="kw">let</span> <span class="ident">n_o_t</span> <span class="op">=</span> <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>;
            <span class="macro">set_current_number_of_tasks</span><span class="macro">!</span>(<span class="ident">n_o_t</span>);
            <span class="comment">/* CURRENT_TCB won&#39;t be None. See task_global.rs. */</span>
            <span class="kw">if</span> <span class="ident">task_global</span>::<span class="ident">CURRENT_TCB</span>.<span class="ident">read</span>().<span class="ident">unwrap</span>().<span class="ident">is_none</span>() {
                <span class="macro">set_current_task_handle</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">clone</span>());
                <span class="kw">if</span> <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>() <span class="op">!=</span> <span class="number">1</span> {
                    <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>(); <span class="comment">// What happened?</span>
                }
            } <span class="kw">else</span> {
                <span class="kw">let</span> <span class="ident">unwrapped_cur</span> <span class="op">=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>();
                <span class="kw">if</span> <span class="op">!</span><span class="macro">get_scheduler_running</span><span class="macro">!</span>() {
                    <span class="kw">if</span> <span class="ident">unwrapped_cur</span>.<span class="ident">get_priority</span>() <span class="op">&lt;=</span> <span class="ident">unwrapped_tcb</span>.<span class="ident">task_priority</span> {
                        <span class="comment">/* If the scheduler is not already running, make this task the
                        current task if it is the highest priority task to be created
                        so far. */</span>
                        <span class="macro">set_current_task_handle</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">clone</span>());
                    } <span class="kw">else</span> {
                        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                    }
                }
            }
            <span class="macro">set_task_number</span><span class="macro">!</span>(<span class="macro">get_task_number</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>);
            <span class="macro">traceTASK_CREATE</span><span class="macro">!</span>(<span class="self">self</span>.<span class="ident">clone</span>());
            <span class="self">self</span>.<span class="ident">add_task_to_ready_list</span>()<span class="question-mark">?</span>;
        }
        <span class="macro">taskEXIT_CRITICAL</span><span class="macro">!</span>();
        <span class="kw">if</span> <span class="macro">get_scheduler_running</span><span class="macro">!</span>() {
            <span class="kw">let</span> <span class="ident">current_task_priority</span> <span class="op">=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>().<span class="ident">get_priority</span>();
            <span class="kw">if</span> <span class="ident">current_task_priority</span> <span class="op">&lt;</span> <span class="ident">unwrapped_tcb</span>.<span class="ident">task_priority</span> {
                <span class="macro">taskYIELD_IF_USING_PREEMPTION</span><span class="macro">!</span>();
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }

        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_event_list_item</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ItemLink</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_event_list_item</span>()
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_state_list_item</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">ItemLink</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_state_list_item</span>()
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_name</span>()
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_run_time</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">TickType</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_run_time</span>()
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_run_time</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">next_val</span>: <span class="ident">TickType</span>) <span class="op">-&gt;</span> <span class="ident">TickType</span> {
        <span class="macro">get_tcb_from_handle_mut</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">set_run_time</span>(<span class="ident">next_val</span>)
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_delay_aborted</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_delay_aborted</span>()
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_delay_aborted</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">next_val</span>: <span class="ident">bool</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="macro">get_tcb_from_handle_mut</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">set_delay_aborted</span>(<span class="ident">next_val</span>)
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_mutex_held_count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_mutex_held_count</span>()
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_mutex_held_count</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">new_count</span>: <span class="ident">UBaseType</span>) {
        <span class="macro">get_tcb_from_handle_mut</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">set_mutex_held_count</span>(<span class="ident">new_count</span>)
    }

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_MUTEXES&quot;</span>)]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_base_priority</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">UBaseType</span> {
        <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="self">self</span>).<span class="ident">get_base_priority</span>()
    }
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">get_tcb_from_handle</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">handle</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {
        <span class="kw">match</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">handle</span>.<span class="number">0</span>.<span class="ident">try_read</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">a</span>) <span class="op">=&gt;</span> <span class="ident">a</span>,
            <span class="prelude-val">Err</span>(<span class="kw">_</span>) <span class="op">=&gt;</span> {
                <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;TCB was locked, read failed&quot;</span>);
                <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Task handle locked!&quot;</span>);
            }
        }
    };
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">get_tcb_from_handle_mut</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">handle</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {
        <span class="kw">match</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">handle</span>.<span class="number">0</span>.<span class="ident">try_write</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">a</span>) <span class="op">=&gt;</span> <span class="ident">a</span>,
            <span class="prelude-val">Err</span>(<span class="kw">_</span>) <span class="op">=&gt;</span> {
                <span class="macro">warn</span><span class="macro">!</span>(<span class="string">&quot;TCB was locked, write failed&quot;</span>);
                <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Task handle locked!&quot;</span>);
            }
        }
    };
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">add_current_task_to_delayed_list</span>(<span class="ident">ticks_to_wait</span>: <span class="ident">TickType</span>, <span class="ident">can_block_indefinitely</span>: <span class="ident">bool</span>) {
    <span class="comment">/*
     * The currently executing task is entering the Blocked state.  Add the task to
     * either the current or the overflow delayed task list.
     */</span>
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;ADD&quot;</span>);

    <span class="kw">let</span> <span class="ident">unwrapped_cur</span> <span class="op">=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>();
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Remove succeeded&quot;</span>);

    {
        <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskAbortDelay&quot;</span>)]</span>
        <span class="comment">/* About to enter a delayed list, so ensure the ucDelayAborted flag is
        reset to pdFALSE so it can be detected as having been set to pdTRUE
        when the task leaves the Blocked state. */</span>

        <span class="ident">unwrapped_cur</span>.<span class="ident">set_delay_aborted</span>(<span class="bool-val">false</span>);

        <span class="comment">// NOTE by Fan Jinhao: Is this line necessary?</span>
        <span class="comment">// set_current_task_handle!(unwrapped_cur);</span>
    }
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Abort succeeded&quot;</span>);

    <span class="comment">/* Remove the task from the ready list before adding it to the blocked list
    as the same list item is used for both lists. */</span>
    <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>()) <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Returned 0&quot;</span>);
        <span class="comment">/* The current task must be in a ready list, so there is no need to
        check, and the port reset macro can be called directly. */</span>
        <span class="macro">portRESET_READY_PRIORITY</span><span class="macro">!</span>(<span class="ident">unwrapped_cur</span>.<span class="ident">get_priority</span>(), <span class="macro">get_top_ready_priority</span><span class="macro">!</span>());
    } <span class="kw">else</span> {
        <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Returned not 0&quot;</span>);
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }

    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Remove succeeded&quot;</span>);
    {
        <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskSuspend&quot;</span>)]</span>
        <span class="kw">if</span> <span class="ident">ticks_to_wait</span> <span class="op">==</span> <span class="ident">portMAX_DELAY</span> <span class="op">&amp;&amp;</span> <span class="ident">can_block_indefinitely</span> {
            <span class="comment">/* Add the task to the suspended task list instead of a delayed task
            list to ensure it is not woken by a timing event.  It will block
            indefinitely. */</span>
            <span class="kw">let</span> <span class="ident">cur_state_list_item</span> <span class="op">=</span> <span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>();
            <span class="ident">list</span>::<span class="ident">list_insert_end</span>(<span class="kw-2">&amp;</span><span class="ident">SUSPENDED_TASK_LIST</span>, <span class="ident">cur_state_list_item</span>);
        } <span class="kw">else</span> {
            <span class="comment">/* Calculate the time at which the task should be woken if the event
            does not occur.  This may overflow but this doesn&#39;t matter, the
            kernel will manage it correctly. */</span>
            <span class="kw">let</span> <span class="ident">time_to_wake</span> <span class="op">=</span> <span class="macro">get_tick_count</span><span class="macro">!</span>() <span class="op">+</span> <span class="ident">ticks_to_wait</span>;

            <span class="comment">/* The list item will be inserted in wake time order. */</span>
            <span class="kw">let</span> <span class="ident">cur_state_list_item</span> <span class="op">=</span> <span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>();
            <span class="ident">list</span>::<span class="ident">set_list_item_value</span>(<span class="kw-2">&amp;</span><span class="ident">cur_state_list_item</span>, <span class="ident">time_to_wake</span>);

            <span class="kw">if</span> <span class="ident">time_to_wake</span> <span class="op">&lt;</span> <span class="macro">get_tick_count</span><span class="macro">!</span>() {
                <span class="comment">/* Wake time has overflowed.  Place this item in the overflow
                list. */</span>
                <span class="ident">list</span>::<span class="ident">list_insert</span>(<span class="kw-2">&amp;</span><span class="ident">OVERFLOW_DELAYED_TASK_LIST</span>, <span class="ident">cur_state_list_item</span>);
            } <span class="kw">else</span> {
                <span class="comment">/* The wake time has not overflowed, so the current block list
                is used. */</span>
                <span class="ident">list</span>::<span class="ident">list_insert</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>, <span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>());

                <span class="comment">/* If the task entering the blocked state was placed at the
                head of the list of blocked tasks then xNextTaskUnblockTime
                needs to be updated too. */</span>
                <span class="kw">if</span> <span class="ident">time_to_wake</span> <span class="op">&lt;</span> <span class="macro">get_next_task_unblock_time</span><span class="macro">!</span>() {
                    <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">time_to_wake</span>);
                } <span class="kw">else</span> {
                    <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                }
            }
        }
    }

    {
        <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskSuspend&quot;</span>))]</span>
        <span class="comment">/* Calculate the time at which the task should be woken if the event
        does not occur.  This may overflow but this doesn&#39;t matter, the kernel
        will manage it correctly. */</span>
        <span class="kw">let</span> <span class="ident">time_to_wake</span> <span class="op">=</span> <span class="macro">get_tick_count</span><span class="macro">!</span>() <span class="op">+</span> <span class="ident">ticks_to_wait</span>;

        <span class="kw">let</span> <span class="ident">cur_state_list_item</span> <span class="op">=</span> <span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>();
        <span class="comment">/* The list item will be inserted in wake time order. */</span>
        <span class="ident">list</span>::<span class="ident">set_list_item_value</span>(<span class="kw-2">&amp;</span><span class="ident">cur_state_list_item</span>, <span class="ident">time_to_wake</span>);

        <span class="kw">if</span> <span class="ident">time_to_wake</span> <span class="op">&lt;</span> <span class="macro">get_tick_count</span><span class="macro">!</span>() {
            <span class="comment">/* Wake time has overflowed.  Place this item in the overflow list. */</span>
            <span class="ident">list</span>::<span class="ident">list_insert</span>(<span class="kw-2">&amp;</span><span class="ident">OVERFLOW_DELAYED_TASK_LIST</span>, <span class="ident">cur_state_list_item</span>);
        } <span class="kw">else</span> {
            <span class="comment">/* The wake time has not overflowed, so the current block list is used. */</span>
            <span class="ident">list</span>::<span class="ident">list_insert</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>, <span class="ident">unwrapped_cur</span>.<span class="ident">get_state_list_item</span>());

            <span class="comment">/* If the task entering the blocked state was placed at the head of the
            list of blocked tasks then xNextTaskUnblockTime needs to be updated
            too. */</span>
            <span class="kw">if</span> <span class="ident">time_to_wake</span> <span class="op">&lt;</span> <span class="macro">get_next_task_unblock_time</span><span class="macro">!</span>() {
                <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">time_to_wake</span>);
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        }

        <span class="comment">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span>
        <span class="comment">// ( void ) xCanBlockIndefinitely;</span>
    }

    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Place succeeded&quot;</span>);
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">reset_next_task_unblock_time</span>() {
    <span class="kw">if</span> <span class="ident">list_is_empty</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>) {
        <span class="comment">/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
        the maximum possible value so it is	extremely unlikely that the
        if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass until
        there is an item in the delayed list. */</span>
        <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">portMAX_DELAY</span>);
    } <span class="kw">else</span> {
        <span class="comment">/* The new current delayed list is not empty, get the value of
        the item at the head of the delayed list.  This is the time at
        which the task at the head of the delayed list should be removed
        from the Blocked state. */</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span> <span class="op">=</span> <span class="ident">get_owner_of_head_entry</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>);
        <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">get_list_item_value</span>(<span class="kw-2">&amp;</span><span class="ident">temp</span>.<span class="ident">get_state_list_item</span>()));
    }
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">get_handle_from_option</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">option</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {
        <span class="kw">match</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">option</span> {
            <span class="prelude-val">Some</span>(<span class="ident">handle</span>) <span class="op">=&gt;</span> <span class="ident">handle</span>,
            <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>(),
        }
    };
}

<span class="doccomment">/// * Descrpition:</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  INCLUDE_vTaskDelete must be defined as 1 for this function to be available.</span>
<span class="doccomment">///  See the configuration section for more information.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  Remove a task from the RTOS real time kernel&#39;s management.  The task being</span>
<span class="doccomment">///  deleted will be removed from all ready, blocked, suspended and event lists.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  NOTE:  The idle task is responsible for freeing the kernel allocated</span>
<span class="doccomment">///  memory from tasks that have been deleted.  It is therefore important that</span>
<span class="doccomment">///  the idle task is not starved of microcontroller processing time if your</span>
<span class="doccomment">///  application makes any calls to vTaskDelete ().  Memory allocated by the</span>
<span class="doccomment">///  task code is not automatically freed, and should be freed before the task</span>
<span class="doccomment">///  is deleted.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  See the demo application file death.c for sample code that utilises</span>
<span class="doccomment">///  vTaskDelete ().</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Implemented by: Huang Yeqi</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// # Arguments:</span>
<span class="doccomment">///  @param xTask The handle of the task to be deleted.  Passing NULL will</span>
<span class="doccomment">///  cause the calling task to be deleted.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Return:</span>
<span class="doccomment">/// </span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskDelete&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_delete</span>(<span class="ident">task_to_delete</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">TaskHandle</span><span class="op">&gt;</span>) {
    <span class="comment">/* If null is passed in here then it is the calling task that is
    being deleted. */</span>
    <span class="kw">let</span> <span class="ident">pxtcb</span> <span class="op">=</span> <span class="macro">get_handle_from_option</span><span class="macro">!</span>(<span class="ident">task_to_delete</span>);

    <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
    {
        <span class="comment">/* Remove task from the ready list. */</span>
        <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">pxtcb</span>.<span class="ident">get_state_list_item</span>()) <span class="op">==</span> <span class="number">0</span> {
            <span class="macro">taskRESET_READY_PRIORITY</span><span class="macro">!</span>(<span class="ident">pxtcb</span>.<span class="ident">get_priority</span>());
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }

        <span class="comment">/* Is the task waiting on an event also? */</span>
        <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">get_list_item_container</span>(<span class="kw-2">&amp;</span><span class="ident">pxtcb</span>.<span class="ident">get_event_list_item</span>()).<span class="ident">is_some</span>() {
            <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">pxtcb</span>.<span class="ident">get_event_list_item</span>());
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }

        <span class="comment">/* Increment the uxTaskNumber also so kernel aware debuggers can
        detect that the task lists need re-generating.  This is done before
        portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
        not return. */</span>
        <span class="macro">set_task_number</span><span class="macro">!</span>(<span class="macro">get_task_number</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>);

        <span class="kw">if</span> <span class="ident">pxtcb</span> <span class="op">==</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>() {
            <span class="comment">/* A task is deleting itself.  This cannot complete within the
            task itself, as a context switch to another task is required.
            Place the task in the termination list.  The idle task will
            check the termination list and free up any memory allocated by
            the scheduler for the TCB and stack of the deleted task. */</span>
            <span class="ident">list</span>::<span class="ident">list_insert_end</span>(<span class="kw-2">&amp;</span><span class="ident">TASKS_WAITING_TERMINATION</span>, <span class="ident">pxtcb</span>.<span class="ident">get_state_list_item</span>());

            <span class="comment">/* Increment the ucTasksDeleted variable so the idle task knows
            there is a task that has been deleted and that it should therefore
            check the xTasksWaitingTermination list. */</span>
            <span class="macro">set_deleted_tasks_waiting_clean_up</span><span class="macro">!</span>(<span class="macro">get_deleted_tasks_waiting_clean_up</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>);

            <span class="comment">/* The pre-delete hook is primarily for the Windows simulator,
            in which Windows specific clean up operations are performed,
            after which it is not possible to yield away from this task -
            hence xYieldPending is used to latch that a context switch is
            required. */</span>
            <span class="macro">portPRE_TASK_DELETE_HOOK</span><span class="macro">!</span>(<span class="ident">pxtcb</span>, <span class="macro">get_yield_pending</span><span class="macro">!</span>());
        } <span class="kw">else</span> {
            <span class="macro">set_current_number_of_tasks</span><span class="macro">!</span>(<span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>() <span class="op">-</span> <span class="number">1</span>);

            <span class="kw">let</span> <span class="ident">stack_pos</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="ident">pxtcb</span>).<span class="ident">stack_pos</span>;
            <span class="comment">/* This call is required specifically for the TriCore port.  It must be
            above the vPortFree() calls.  The call is also used by ports/demos that
            want to allocate and clean RAM statically. */</span>
            <span class="ident">port</span>::<span class="ident">port_free</span>(<span class="ident">stack_pos</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>);

            <span class="comment">/* Reset the next expected unblock time in case it referred to
            the task that has just been deleted. */</span>
            <span class="ident">reset_next_task_unblock_time</span>();
        }
        <span class="comment">// FIXME</span>
        <span class="comment">//traceTASK_DELETE!(task_to_delete);</span>
    }
    <span class="macro">taskEXIT_CRITICAL</span><span class="macro">!</span>();

    <span class="comment">/* Force a reschedule if it is the currently running task that has just
    been deleted. */</span>
    <span class="kw">if</span> <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">&gt;</span> <span class="number">0</span> {
        <span class="kw">if</span> <span class="ident">pxtcb</span> <span class="op">==</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>() {
            <span class="macro">assert</span><span class="macro">!</span>(<span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">==</span> <span class="number">0</span>);
            <span class="macro">portYIELD_WITHIN_API</span><span class="macro">!</span>();
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }
    }
}

<span class="doccomment">/// * Descrpition:</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.</span>
<span class="doccomment">///  See the configuration section for more information.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  Suspend any task.  When suspended a task will never get any microcontroller</span>
<span class="doccomment">///  processing time, no matter what its priority.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  Calls to vTaskSuspend are not accumulative -</span>
<span class="doccomment">///  i.e. calling vTaskSuspend () twice on the same task still only requires one</span>
<span class="doccomment">///  call to vTaskResume () to ready the suspended task.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Implemented by: Huang Yeqi</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// # Arguments:</span>
<span class="doccomment">///  @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL</span>
<span class="doccomment">///  handle will cause the calling task to be suspended.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Return:</span>
<span class="doccomment">/// </span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskSuspend&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">suspend_task</span>(<span class="ident">task_to_suspend</span>: <span class="ident">TaskHandle</span>) {
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;suspend_task called!&quot;</span>);
    <span class="comment">/*
     * origin: If null is passed in here then it is the running task that is
     * being suspended. In our implement, you can just pass the TaskHandle of the current task
     */</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">unwrapped_tcb</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="ident">task_to_suspend</span>);
    <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
    {
        <span class="macro">traceTASK_SUSPEND</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>);

        <span class="comment">/* Remove task from the ready/delayed list and place in the
        suspended list. */</span>
        <span class="kw">if</span> <span class="ident">list_remove</span>(<span class="ident">unwrapped_tcb</span>.<span class="ident">get_state_list_item</span>()) <span class="op">==</span> <span class="number">0</span> {
            <span class="macro">taskRESET_READY_PRIORITY</span><span class="macro">!</span>(<span class="ident">unwrapped_tcb</span>.<span class="ident">get_priority</span>());
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }

        <span class="comment">/* Is the task waiting on an event also? */</span>
        <span class="kw">if</span> <span class="ident">get_list_item_container</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>.<span class="ident">get_event_list_item</span>()).<span class="ident">is_some</span>() {
            <span class="ident">list_remove</span>(<span class="ident">unwrapped_tcb</span>.<span class="ident">get_event_list_item</span>());
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }
        <span class="ident">list_insert_end</span>(<span class="kw-2">&amp;</span><span class="ident">SUSPENDED_TASK_LIST</span>, <span class="ident">unwrapped_tcb</span>.<span class="ident">get_state_list_item</span>());
    }
    <span class="macro">taskEXIT_CRITICAL</span><span class="macro">!</span>();

    <span class="kw">if</span> <span class="macro">get_scheduler_running</span><span class="macro">!</span>() {
        <span class="comment">/* Reset the next expected unblock time in case it referred to the
        task that is now in the Suspended state. */</span>
        <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
        {
            <span class="ident">reset_next_task_unblock_time</span>();
        }
        <span class="macro">taskEXIT_CRITICAL</span><span class="macro">!</span>();
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }

    <span class="kw">if</span> <span class="ident">task_to_suspend</span> <span class="op">==</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>() {
        <span class="kw">if</span> <span class="macro">get_scheduler_running</span><span class="macro">!</span>() {
            <span class="comment">/* The current task has just been suspended. */</span>
            <span class="macro">assert</span><span class="macro">!</span>(<span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">==</span> <span class="number">0</span>);
            <span class="macro">portYIELD_WITHIN_API</span><span class="macro">!</span>();
        } <span class="kw">else</span> {
            <span class="comment">/* The scheduler is not running, but the task that was pointed
            to by pxCurrentTCB has just been suspended and pxCurrentTCB
            must be adjusted to point to a different task. */</span>
            <span class="kw">if</span> <span class="ident">current_list_length</span>(<span class="kw-2">&amp;</span><span class="ident">SUSPENDED_TASK_LIST</span>) <span class="op">!=</span> <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>() {
                <span class="ident">task_switch_context</span>();
            }
            <span class="comment">//TODO: comprehend the implement of cuurrent_tcb</span>
            <span class="comment">/* But is the Source code, if the length == current number, it means no other tasks are ready, so set pxCurrentTCB back to
            NULL so when the next task is created pxCurrentTCB will
            be set to point to it no matter what its relative priority
            is. */</span>
        }
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskSuspend&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_is_tasksuspended</span>(<span class="ident">xtask</span>: <span class="kw-2">&amp;</span><span class="ident">TaskHandle</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">xreturn</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="bool-val">false</span>;
    <span class="kw">let</span> <span class="ident">tcb</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="ident">xtask</span>);
    <span class="comment">/* Accesses xPendingReadyList so must be called from a critical
    section. */</span>

    <span class="comment">/* It does not make sense to check if the calling task is suspended. */</span>
    <span class="comment">//assert!( xtask );</span>

    <span class="comment">/* Is the task being resumed actually in the suspended list? */</span>
    <span class="kw">if</span> <span class="ident">is_contained_within</span>(<span class="kw-2">&amp;</span><span class="ident">SUSPENDED_TASK_LIST</span>, <span class="kw-2">&amp;</span><span class="ident">tcb</span>.<span class="ident">get_state_list_item</span>()) {
        <span class="comment">/* Has the task already been resumed from within an ISR? */</span>
        <span class="kw">if</span> <span class="op">!</span><span class="ident">is_contained_within</span>(<span class="kw-2">&amp;</span><span class="ident">PENDING_READY_LIST</span>, <span class="kw-2">&amp;</span><span class="ident">tcb</span>.<span class="ident">get_event_list_item</span>()) {
            <span class="comment">/* Is it in the suspended list because it is in the	Suspended
            state, or because is is blocked with no timeout? */</span>
            <span class="kw">if</span> <span class="ident">get_list_item_container</span>(<span class="kw-2">&amp;</span><span class="ident">tcb</span>.<span class="ident">get_event_list_item</span>()).<span class="ident">is_none</span>() {
                <span class="ident">xreturn</span> <span class="op">=</span> <span class="bool-val">true</span>;
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }

    <span class="ident">xreturn</span>
}

<span class="doccomment">/// * Descrpition:</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  task. h</span>
<span class="doccomment">///  &lt;pre&gt;void vTaskResume( TaskHandle_t xTaskToResume );&lt;/pre&gt;</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.</span>
<span class="doccomment">///  See the configuration section for more information.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  Resumes a suspended task.</span>
<span class="doccomment">/// </span>
<span class="doccomment">///  A task that has been suspended by one or more calls to vTaskSuspend ()</span>
<span class="doccomment">///  will be made available for running again by a single call to</span>
<span class="doccomment">///  vTaskResume ().</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Implemented by: Huang Yeqi</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// # Arguments:</span>
<span class="doccomment">///  @param xTaskToResume Handle to the task being readied.</span>
<span class="doccomment">/// </span>
<span class="doccomment">/// * Return:</span>
<span class="doccomment">/// </span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_vTaskSuspend&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">resume_task</span>(<span class="ident">task_to_resume</span>: <span class="ident">TaskHandle</span>) {
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;resume task called!&quot;</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">unwrapped_tcb</span> <span class="op">=</span> <span class="macro">get_tcb_from_handle</span><span class="macro">!</span>(<span class="ident">task_to_resume</span>);

    <span class="kw">if</span> <span class="ident">task_to_resume</span> <span class="op">!=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>() {
        <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
        {
            <span class="kw">if</span> <span class="ident">task_is_tasksuspended</span>(<span class="kw-2">&amp;</span><span class="ident">task_to_resume</span>) {
                <span class="macro">traceTASK_RESUME</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">unwrapped_tcb</span>);

                <span class="comment">/* As we are in a critical section we can access the ready
                lists even if the scheduler is suspended. */</span>
                <span class="ident">list_remove</span>(<span class="ident">unwrapped_tcb</span>.<span class="ident">get_state_list_item</span>());
                <span class="ident">task_to_resume</span>.<span class="ident">add_task_to_ready_list</span>();

                <span class="kw">let</span> <span class="ident">current_task_priority</span> <span class="op">=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>().<span class="ident">get_priority</span>();
                <span class="comment">/* We may have just resumed a higher priority task. */</span>
                <span class="kw">if</span> <span class="ident">unwrapped_tcb</span>.<span class="ident">get_priority</span>() <span class="op">&gt;=</span> <span class="ident">current_task_priority</span> {
                    <span class="comment">/* This yield may not cause the task just resumed to run,
                    but will leave the lists in the correct state for the
                    next yield. */</span>
                    <span class="macro">taskYIELD_IF_USING_PREEMPTION</span><span class="macro">!</span>();
                } <span class="kw">else</span> {
                    <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                }
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        }
        <span class="macro">taskEXIT_CRITICAL</span><span class="macro">!</span>();
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rust_freertos";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>