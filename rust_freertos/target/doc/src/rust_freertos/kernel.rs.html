<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `src/kernel.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>kernel.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rust_freertos/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="comment">// kernel.rs, FreeRTOS scheduler control APIs.</span>
<span class="comment">// This file is created by Fan Jinhao.</span>
<span class="comment">// Functions defined in this file are explained in Chapter 9 and 10.</span>
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">list</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">port</span>::<span class="ident">UBaseType</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">projdefs</span>::<span class="ident">pdFALSE</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">task_control</span>::{<span class="ident">TaskHandle</span>, <span class="ident">TCB</span>};
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">task_global</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="kw">crate</span>::<span class="kw-2">*</span>; <span class="comment">// TODO: Is this line necessary?</span>
              <span class="comment">// use crate::task_control::TCB;</span>

<span class="comment">/* Definitions returned by xTaskGetSchedulerState().
 * The originial definitons are C constants, we changed them to enums.
 */</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SchedulerState</span> {
    <span class="ident">NotStarted</span>,
    <span class="ident">Suspended</span>,
    <span class="ident">Running</span>,
}

<span class="doccomment">/// Macro for forcing a context switch.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskYIELD</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portYIELD</span><span class="macro">!</span>()
    };
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskYIELD_IF_USING_PREEMPTION</span> {
    () <span class="op">=&gt;</span> {
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>)]</span>
        <span class="macro">portYIELD_WITHIN_API</span><span class="macro">!</span>();
    };
}

<span class="doccomment">/// Macro to mark the start of a critical code region.  Preemptive context</span>
<span class="doccomment">/// switches cannot occur when in a critical region.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// NOTE: This may alter the stack (depending on the portable implementation)</span>
<span class="doccomment">/// so must be used with care!</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskENTER_CRITICAL</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portENTER_CRITICAL</span><span class="macro">!</span>()
    };
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskENTER_CRITICAL_FROM_ISR</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portSET_INTERRUPT_MASK_FROM_ISR</span><span class="macro">!</span>()
    };
}

<span class="doccomment">/// Macro to mark the end of a critical code region.  Preemptive context</span>
<span class="doccomment">/// switches cannot occur when in a critical region.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// NOTE: This may alter the stack (depending on the portable implementation)</span>
<span class="doccomment">/// so must be used with care!</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskEXIT_CRITICAL</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portEXIT_CRITICAL</span><span class="macro">!</span>()
    };
}

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskEXIT_CRITICAL_FROM_ISR</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">x</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {
        <span class="macro">portCLEAR_INTERRUPT_MASK_FROM_ISR</span><span class="macro">!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">x</span>)
    };
}

<span class="doccomment">/// Macro to disable all maskable interrupts.</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation: task.h</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskDISABLE_INTERRUPTS</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portDISABLE_INTERRUPTS</span><span class="macro">!</span>()
    };
}

<span class="doccomment">/// Macro to enable microcontroller interrupts.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation: task.h</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>

<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskENABLE_INTERRUPTS</span> {
    () <span class="op">=&gt;</span> {
        <span class="macro">portENABLE_INTERRUPTS</span><span class="macro">!</span>()
    };
}

<span class="doccomment">///</span>
<span class="doccomment">/// Starts the real time kernel tick processing.  After calling the kernel</span>
<span class="doccomment">/// has control over which tasks are executed and when.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the demo application file main.c for an example of creating</span>
<span class="doccomment">/// tasks and starting the kernel.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="doccomment">///</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_start_scheduler</span>() {
    <span class="ident">create_idle_task</span>();

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TIMERS&quot;</span>)]</span>
    <span class="ident">create_timer_task</span>();

    <span class="ident">initialize_scheduler</span>();
}

<span class="doccomment">/// The fist part of task_start_scheduler(), creates the idle task.</span>
<span class="doccomment">/// Will panic if task creation fails.</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation: tasks.c 1831-1866</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">create_idle_task</span>() <span class="op">-&gt;</span> <span class="ident">TaskHandle</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;number: {}&quot;</span>, <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>());
    <span class="kw">let</span> <span class="ident">idle_task_fn</span> <span class="op">=</span> <span class="op">||</span> {
        <span class="kw">loop</span> {
            <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Idle Task running&quot;</span>);
            <span class="comment">/* THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
            SCHEDULER IS STARTED. */</span>

            <span class="comment">/* See if any tasks have deleted themselves - if so then the idle task
            is responsible for freeing the deleted task&#39;s TCB and stack. */</span>
            <span class="ident">check_tasks_waiting_termination</span>();

            <span class="comment">/* If we are not using preemption we keep forcing a task switch to
            see if any other task has become available.  If we are using
            preemption we don&#39;t need to do this as any task becoming available
            will automatically get the processor anyway. */</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>))]</span>
            <span class="macro">taskYIELD</span><span class="macro">!</span>();

            {
                <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configIDLE_SHOULD_YIELD&quot;</span>))]</span>
                <span class="comment">/* When using preemption tasks of equal priority will be
                timesliced.  If a task that is sharing the idle priority is ready
                to run then the idle task should yield before the end of the
                timeslice.

                A critical region is not required here as we are just reading from
                the list, and an occasional incorrect value will not matter.  If
                the ready list at the idle priority contains more than one task
                then a task other than the idle task is ready to execute. */</span>
                <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">current_list_length</span>(<span class="kw-2">&amp;</span><span class="ident">READY_TASK_LISTS</span>[<span class="number">0</span>]) <span class="op">&gt;</span> <span class="number">1</span> {
                    <span class="macro">taskYIELD</span><span class="macro">!</span>();
                } <span class="kw">else</span> {
                    <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                }
            }

            {
                <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_IDLE_HOOK&quot;</span>)]</span>
                <span class="comment">// TODO: Use IdleHook</span>
                <span class="comment">// extern void vApplicationIdleHook( void );</span>

                <span class="comment">/* Call the user defined function from within the idle task.  This
                allows the application designer to add background functionality
                without the overhead of a separate task.
                NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                CALL A FUNCTION THAT MIGHT BLOCK. */</span>
                <span class="comment">// vApplicationIdleHook();</span>
                <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Idle Task running&quot;</span>);
            }
        }
    };

    <span class="ident">TCB</span>::<span class="ident">new</span>()
        .<span class="ident">priority</span>(<span class="number">0</span>)
        .<span class="ident">name</span>(<span class="string">&quot;Idle&quot;</span>)
        .<span class="ident">initialise</span>(<span class="ident">idle_task_fn</span>)
        .<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="ident">err</span><span class="op">|</span> <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Idle task creation failed with error: {:?}&quot;</span>, <span class="ident">err</span>))
}

<span class="kw">fn</span> <span class="ident">check_tasks_waiting_termination</span>() {
    <span class="comment">// TODO: Wait for task_delete.</span>
}

<span class="doccomment">/// The second (optional) part of task_start_scheduler(),</span>
<span class="doccomment">/// creates the timer task. Will panic if task creation fails.</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation: tasks.c 1868-1879</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="kw">fn</span> <span class="ident">create_timer_task</span>() {
    <span class="comment">// TODO: This function relies on the software timer, which we may not implement.</span>
    <span class="comment">// timer::create_timer_task()</span>
    <span class="comment">// On fail, panic!(&quot;No enough heap space to allocate timer task.&quot;);</span>
}

<span class="doccomment">/// The third part of task_step_scheduler, do some initialziation</span>
<span class="doccomment">/// and call port_start_scheduler() to set up the timer tick.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation: tasks.c 1881-1918.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="kw">fn</span> <span class="ident">initialize_scheduler</span>() {
    <span class="comment">/* Interrupts are turned off here, to ensure a tick does not occur
    before or during the call to xPortStartScheduler().  The stacks of
    the created tasks contain a status word with interrupts switched on
    so interrupts will automatically get re-enabled when the first task
    starts to run. */</span>
    <span class="macro">portDISABLE_INTERRUPTS</span><span class="macro">!</span>();

    <span class="comment">// TODO: NEWLIB</span>

    <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">port</span>::<span class="ident">portMAX_DELAY</span>);
    <span class="macro">set_scheduler_running</span><span class="macro">!</span>(<span class="bool-val">true</span>);
    <span class="macro">set_tick_count</span><span class="macro">!</span>(<span class="number">0</span>);

    <span class="comment">/* If configGENERATE_RUN_TIME_STATS is defined then the following
    macro must be defined to configure the timer/counter used to generate
    the run time counter time base. */</span>
    <span class="macro">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="macro">!</span>();

    <span class="comment">/* Setting up the timer tick is hardware specific and thus in the
    portable interface. */</span>
    <span class="kw">if</span> <span class="ident">port</span>::<span class="ident">port_start_scheduler</span>() <span class="op">!=</span> <span class="ident">pdFALSE</span> {
        <span class="comment">/* Should not reach here as if the scheduler is running the
        function will not return. */</span>
    } <span class="kw">else</span> {
        <span class="comment">// TODO: Maybe a trace here?</span>
        <span class="comment">/* Should only reach here if a task calls xTaskEndScheduler(). */</span>
    }
}

<span class="doccomment">/// NOTE:  At the time of writing only the x86 real mode port, which runs on a PC</span>
<span class="doccomment">/// in place of DOS, implements this function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Stops the real time kernel tick.  All created tasks will be automatically</span>
<span class="doccomment">/// deleted and multitasking (either preemptive or cooperative) will</span>
<span class="doccomment">/// stop.  Execution then resumes from the point where vTaskStartScheduler ()</span>
<span class="doccomment">/// was called, as if vTaskStartScheduler () had just returned.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See the demo application file main. c in the demo/PC directory for an</span>
<span class="doccomment">/// example that uses vTaskEndScheduler ().</span>
<span class="doccomment">///</span>
<span class="doccomment">/// vTaskEndScheduler () requires an exit function to be defined within the</span>
<span class="doccomment">/// portable layer (see vPortEndScheduler () in port. c for the PC port).  This</span>
<span class="doccomment">/// performs hardware specific operations such as stopping the kernel tick.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// vTaskEndScheduler () will cause all of the resources allocated by the</span>
<span class="doccomment">/// kernel to be freed - but will not free resources allocated by application</span>
<span class="doccomment">/// tasks.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_end_scheduler</span>() {
    <span class="comment">/* Stop the scheduler interrupts and call the portable scheduler end
    routine so the original ISRs can be restored if necessary.  The port
    layer must ensure interrupts enable bit is left in the correct state. */</span>
    <span class="macro">portDISABLE_INTERRUPTS</span><span class="macro">!</span>();
    <span class="macro">set_scheduler_running</span><span class="macro">!</span>(<span class="bool-val">false</span>);
    <span class="ident">port</span>::<span class="ident">port_end_scheduler</span>();
}

<span class="doccomment">/// Suspends the scheduler without disabling interrupts.  Context switches will</span>
<span class="doccomment">/// not occur while the scheduler is suspended.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// After calling vTaskSuspendAll () the calling task will continue to execute</span>
<span class="doccomment">/// without risk of being swapped out until a call to xTaskResumeAll () has been</span>
<span class="doccomment">/// made.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// API functions that have the potential to cause a context switch (for example,</span>
<span class="doccomment">/// vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler</span>
<span class="doccomment">/// is suspended.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_suspend_all</span>() {
    <span class="comment">/* A critical section is not required as the variable is of type
    BaseType_t.  Please read Richard Barry&#39;s reply in the following link to a
    post in the FreeRTOS support forum before reporting this as a bug! -
    http://goo.gl/wu4acr */</span>

    <span class="comment">// Increment SCHEDULER_SUSPENDED.</span>
    <span class="macro">set_scheduler_suspended</span><span class="macro">!</span>(<span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>);
}

<span class="doccomment">/// Resumes scheduler activity after it was suspended by a call to</span>
<span class="doccomment">/// vTaskSuspendAll().</span>
<span class="doccomment">///</span>
<span class="doccomment">/// xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks</span>
<span class="doccomment">/// that were previously suspended by a call to vTaskSuspend().</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If resuming the scheduler caused a context switch then true is</span>
<span class="doccomment">/// returned, otherwise false is returned.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_resume_all</span>() <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;resume_all called!&quot;</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">already_yielded</span> <span class="op">=</span> <span class="bool-val">false</span>;

    <span class="comment">// TODO: This is a recoverable error, use Result&lt;&gt; instead.</span>
    <span class="macro">assert</span><span class="macro">!</span>(
        <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">&gt;</span> <span class="ident">pdFALSE</span> <span class="kw">as</span> <span class="ident">UBaseType</span>,
        <span class="string">&quot;The call to task_resume_all() does not match \
         a previous call to vTaskSuspendAll().&quot;</span>
    );

    <span class="comment">/* It is possible that an ISR caused a task to be removed from an event
    list while the scheduler was suspended.  If this was the case then the
    removed task will have been added to the xPendingReadyList.  Once the
    scheduler has been resumed it is safe to move all the pending ready
    tasks from this list into their appropriate ready list. */</span>
    <span class="macro">taskENTER_CRITICAL</span><span class="macro">!</span>();
    {
        <span class="comment">// Decrement SCHEDULER_SUSPENDED.</span>
        <span class="macro">set_scheduler_suspended</span><span class="macro">!</span>(<span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">-</span> <span class="number">1</span>);
        <span class="macro">println</span><span class="macro">!</span>(
            <span class="string">&quot;get_current_number_of_tasks: {}&quot;</span>,
            <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>()
        );
        <span class="kw">if</span> <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">==</span> <span class="ident">pdFALSE</span> <span class="kw">as</span> <span class="ident">UBaseType</span> {
            <span class="kw">if</span> <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>() <span class="op">&gt;</span> <span class="number">0</span> {
                <span class="macro">trace</span><span class="macro">!</span>(
                    <span class="string">&quot;Current number of tasks is: {}, move tasks to ready list.&quot;</span>,
                    <span class="macro">get_current_number_of_tasks</span><span class="macro">!</span>()
                );
                <span class="comment">/* Move any readied tasks from the pending list into the
                appropriate ready list. */</span>
                <span class="kw">if</span> <span class="ident">move_tasks_to_ready_list</span>() {
                    <span class="comment">/* A task was unblocked while the scheduler was suspended,
                    which may have prevented the next unblock time from being
                    re-calculated, in which case re-calculate it now.  Mainly
                    important for low power tickless implementations, where
                    this can prevent an unnecessary exit from low power
                    state. */</span>
                    <span class="ident">reset_next_task_unblock_time</span>();
                }

                <span class="comment">/* If any ticks occurred while the scheduler was suspended then
                they should be processed now.  This ensures the tick count does
                not slip, and that any delayed tasks are resumed at the correct
                time. */</span>
                <span class="ident">process_pended_ticks</span>();

                <span class="kw">if</span> <span class="macro">get_yield_pending</span><span class="macro">!</span>() {
                    {
                        <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>)]</span>
                        <span class="ident">already_yielded</span> <span class="op">=</span> <span class="bool-val">true</span>;
                    }

                    <span class="macro">taskYIELD_IF_USING_PREEMPTION</span><span class="macro">!</span>();
                } <span class="kw">else</span> {
                    <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                }
            }
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }
    }

    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Already yielded is {}&quot;</span>, <span class="ident">already_yielded</span>);
    <span class="ident">already_yielded</span>
}

<span class="kw">fn</span> <span class="ident">move_tasks_to_ready_list</span>() <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">has_unblocked_task</span> <span class="op">=</span> <span class="bool-val">false</span>;
    <span class="kw">while</span> <span class="op">!</span><span class="ident">list</span>::<span class="ident">list_is_empty</span>(<span class="kw-2">&amp;</span><span class="ident">PENDING_READY_LIST</span>) {
        <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;PEDING_LIST not empty&quot;</span>);
        <span class="ident">has_unblocked_task</span> <span class="op">=</span> <span class="bool-val">true</span>;
        <span class="kw">let</span> <span class="ident">task_handle</span> <span class="op">=</span> <span class="ident">list</span>::<span class="ident">get_owner_of_head_entry</span>(<span class="kw-2">&amp;</span><span class="ident">PENDING_READY_LIST</span>);
        <span class="kw">let</span> <span class="ident">event_list_item</span> <span class="op">=</span> <span class="ident">task_handle</span>.<span class="ident">get_event_list_item</span>();
        <span class="kw">let</span> <span class="ident">state_list_item</span> <span class="op">=</span> <span class="ident">task_handle</span>.<span class="ident">get_state_list_item</span>();

        <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">state_list_item</span>);
        <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">event_list_item</span>);

        <span class="ident">task_handle</span>.<span class="ident">add_task_to_ready_list</span>().<span class="ident">unwrap</span>();

        <span class="comment">/* If the moved task has a priority higher than the current
        task then a yield must be performed. */</span>
        <span class="kw">if</span> <span class="ident">task_handle</span>.<span class="ident">get_priority</span>() <span class="op">&gt;=</span> <span class="macro">get_current_task_priority</span><span class="macro">!</span>() {
            <span class="macro">set_yield_pending</span><span class="macro">!</span>(<span class="bool-val">true</span>);
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }
    }
    <span class="ident">has_unblocked_task</span>
}

<span class="kw">fn</span> <span class="ident">reset_next_task_unblock_time</span>() {
    <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">list_is_empty</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>) {
        <span class="comment">/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
        the maximum possible value so it is	extremely unlikely that the
        if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass until
        there is an item in the delayed list. */</span>
        <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">port</span>::<span class="ident">portMAX_DELAY</span>);
    } <span class="kw">else</span> {
        <span class="comment">/* The new current delayed list is not empty, get the value of
        the item at the head of the delayed list.  This is the time at
        which the task at the head of the delayed list should be removed
        from the Blocked state. */</span>
        <span class="kw">let</span> <span class="ident">task_handle</span> <span class="op">=</span> <span class="ident">list</span>::<span class="ident">get_owner_of_head_entry</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>);
        <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">list</span>::<span class="ident">get_list_item_value</span>(
            <span class="kw-2">&amp;</span><span class="ident">task_handle</span>.<span class="ident">get_state_list_item</span>()
        ));
    }
}

<span class="kw">fn</span> <span class="ident">process_pended_ticks</span>() {
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Processing pended ticks&quot;</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pended_counts</span> <span class="op">=</span> <span class="macro">get_pended_ticks</span><span class="macro">!</span>();

    <span class="kw">if</span> <span class="ident">pended_counts</span> <span class="op">&gt;</span> <span class="number">0</span> {
        <span class="kw">loop</span> {
            <span class="kw">if</span> <span class="ident">task_increment_tick</span>() {
                <span class="macro">set_yield_pending</span><span class="macro">!</span>(<span class="bool-val">true</span>);
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }

            <span class="ident">pended_counts</span> <span class="op">-=</span> <span class="number">1</span>;

            <span class="kw">if</span> <span class="ident">pended_counts</span> <span class="op">&lt;=</span> <span class="number">0</span> {
                <span class="kw">break</span>;
            }
        }

        <span class="macro">set_pended_ticks</span><span class="macro">!</span>(<span class="number">0</span>);
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }
}

<span class="doccomment">/// Only available when configUSE_TICKLESS_IDLE is set to 1.</span>
<span class="doccomment">/// If tickless mode is being used, or a low power mode is implemented, then</span>
<span class="doccomment">/// the tick interrupt will not execute during idle periods.  When this is the</span>
<span class="doccomment">/// case, the tick count value maintained by the scheduler needs to be kept up</span>
<span class="doccomment">/// to date with the actual execution time by being skipped forward by a time</span>
<span class="doccomment">/// equal to the idle period.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TICKLESS_IDLE&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_step_tick</span>(<span class="ident">ticks_to_jump</span>: <span class="ident">TickType</span>) {
    <span class="comment">/* Correct the tick count value after a period during which the tick
    was suppressed.  Note this does *not* call the tick hook function for
    each stepped tick. */</span>
    <span class="kw">let</span> <span class="ident">cur_tick_count</span> <span class="op">=</span> <span class="macro">get_tick_count</span><span class="macro">!</span>(); <span class="comment">// NOTE: Is this a bug in FreeRTOS?</span>
    <span class="kw">let</span> <span class="ident">next_task_unblock_time</span> <span class="op">=</span> <span class="macro">get_next_task_unblock_time</span><span class="macro">!</span>();

    <span class="comment">// TODO: Add explanations about this assertion.</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">cur_tick_count</span> <span class="op">+</span> <span class="ident">ticks_to_jump</span> <span class="op">&lt;=</span> <span class="ident">next_task_unblock_time</span>);

    <span class="macro">set_tick_count</span><span class="macro">!</span>(<span class="ident">cur_tick_count</span> <span class="op">+</span> <span class="ident">ticks_to_jump</span>);

    <span class="macro">traceINCREASE_TICK_COUNT</span><span class="macro">!</span>(<span class="ident">xTicksToJump</span>);
}

<span class="doccomment">/// THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY</span>
<span class="doccomment">/// INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS</span>
<span class="doccomment">/// AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Sets the pointer to the current TCB to the TCB of the highest priority task</span>
<span class="doccomment">/// that is ready to run.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * Implemented by: Fan Jinhao.</span>
<span class="doccomment">/// * C implementation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Arguments</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Return</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nothing</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_switch_context</span>() {
    <span class="kw">if</span> <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">&gt;</span> <span class="ident">pdFALSE</span> <span class="kw">as</span> <span class="ident">UBaseType</span> {
        <span class="comment">/* The scheduler is currently suspended - do not allow a context
        switch. */</span>
        <span class="macro">set_yield_pending</span><span class="macro">!</span>(<span class="bool-val">true</span>);
    } <span class="kw">else</span> {
        <span class="macro">set_yield_pending</span><span class="macro">!</span>(<span class="bool-val">false</span>);
        <span class="macro">traceTASK_SWITCHED_OUT</span><span class="macro">!</span>();

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
        <span class="ident">generate_context_switch_stats</span>();

        <span class="comment">/* Check for stack overflow, if configured. */</span>
        <span class="macro">taskCHECK_FOR_STACK_OVERFLOW</span><span class="macro">!</span>();

        <span class="comment">/* Select a new task to run using either the generic Rust or port
        optimised asm code. */</span>
        <span class="ident">task_select_highest_priority_task</span>();
        <span class="macro">traceTASK_SWITCHED_IN</span><span class="macro">!</span>();

        <span class="comment">// TODO: configUSE_NEWLIB_REENTRANT</span>
    }
}

<span class="comment">/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
performed in a generic way that is not optimised to any particular
microcontroller architecture. */</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PORT_OPTIMISED_TASK_SELECTION&quot;</span>))]</span>
<span class="kw">fn</span> <span class="ident">task_select_highest_priority_task</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">top_priority</span>: <span class="ident">UBaseType</span> <span class="op">=</span> <span class="macro">get_top_ready_priority</span><span class="macro">!</span>();

    <span class="comment">/* Find the highest priority queue that contains ready tasks. */</span>
    <span class="kw">while</span> <span class="ident">list</span>::<span class="ident">list_is_empty</span>(<span class="kw-2">&amp;</span><span class="ident">READY_TASK_LISTS</span>[<span class="ident">top_priority</span> <span class="kw">as</span> <span class="ident">usize</span>]) {
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">top_priority</span> <span class="op">&gt;</span> <span class="number">0</span>, <span class="string">&quot;No task found with a non-zero priority&quot;</span>);
        <span class="ident">top_priority</span> <span class="op">-=</span> <span class="number">1</span>;
    }

    <span class="comment">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of
    the same priority get an equal share of the processor time. */</span>
    <span class="kw">let</span> <span class="ident">next_task</span> <span class="op">=</span> <span class="ident">list</span>::<span class="ident">get_owner_of_next_entry</span>(<span class="kw-2">&amp;</span><span class="ident">READY_TASK_LISTS</span>[<span class="ident">top_priority</span> <span class="kw">as</span> <span class="ident">usize</span>]);

    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Next task is {}&quot;</span>, <span class="ident">next_task</span>.<span class="ident">get_name</span>());
    <span class="macro">set_current_task_handle</span><span class="macro">!</span>(<span class="ident">next_task</span>);

    <span class="macro">set_top_ready_priority</span><span class="macro">!</span>(<span class="ident">top_priority</span>);
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configGENERATE_RUN_TIME_STATS&quot;</span>)]</span>
<span class="kw">fn</span> <span class="ident">generate_context_switch_stats</span>() {
    <span class="comment">/*
    #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
    portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
    #else
    ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    #endif
    */</span>
    <span class="kw">let</span> <span class="ident">total_run_time</span> <span class="op">=</span> <span class="macro">portGET_RUN_TIME_COUNTER_VALUE</span><span class="macro">!</span>() <span class="kw">as</span> <span class="ident">u32</span>;
    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;Total runtime: {}&quot;</span>, <span class="ident">total_run_time</span>);
    <span class="macro">set_total_run_time</span><span class="macro">!</span>(<span class="ident">total_run_time</span>);

    <span class="comment">/* Add the amount of time the task has been running to the
    accumulated time so far.  The time the task started running was
    stored in ulTaskSwitchedInTime.  Note that there is no overflow
    protection here so count values are only valid until the timer
    overflows.  The guard against negative values is to protect
    against suspect run time stat counter implementations - which
    are provided by the application, not the kernel. */</span>
    <span class="kw">let</span> <span class="ident">task_switched_in_time</span> <span class="op">=</span> <span class="macro">get_task_switch_in_time</span><span class="macro">!</span>();
    <span class="kw">if</span> <span class="ident">total_run_time</span> <span class="op">&gt;</span> <span class="ident">task_switched_in_time</span> {
        <span class="kw">let</span> <span class="ident">current_task</span> <span class="op">=</span> <span class="macro">get_current_task_handle</span><span class="macro">!</span>();
        <span class="kw">let</span> <span class="ident">old_run_time</span> <span class="op">=</span> <span class="ident">current_task</span>.<span class="ident">get_run_time</span>();
        <span class="ident">current_task</span>.<span class="ident">set_run_time</span>(<span class="ident">old_run_time</span> <span class="op">+</span> <span class="ident">total_run_time</span> <span class="op">-</span> <span class="ident">task_switched_in_time</span>);
    } <span class="kw">else</span> {
        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
    }
    <span class="macro">set_task_switch_in_time</span><span class="macro">!</span>(<span class="ident">total_run_time</span>);
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_increment_tick</span>() <span class="op">-&gt;</span> <span class="ident">bool</span> {
    <span class="comment">// TODO: tasks.c 2500</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">switch_required</span> <span class="op">=</span> <span class="bool-val">false</span>;

    <span class="comment">/* Called by the portable layer each time a tick interrupt occurs.
    Increments the tick then checks to see if the new tick value will cause any
    tasks to be unblocked. */</span>
    <span class="macro">traceTASK_INCREMENT_TICK</span><span class="macro">!</span>(<span class="macro">get_tick_count</span><span class="macro">!</span>());

    <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;SCHEDULER_SUSP is {}&quot;</span>, <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>());
    <span class="kw">if</span> <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">==</span> <span class="ident">pdFALSE</span> <span class="kw">as</span> <span class="ident">UBaseType</span> {
        <span class="comment">/* Minor optimisation.  The tick count cannot change in this
        block. */</span>
        <span class="kw">let</span> <span class="ident">const_tick_count</span> <span class="op">=</span> <span class="macro">get_tick_count</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>;

        <span class="comment">/* Increment the RTOS tick, switching the delayed and overflowed
        delayed lists if it wraps to 0. */</span>
        <span class="macro">set_tick_count</span><span class="macro">!</span>(<span class="ident">const_tick_count</span>);

        <span class="kw">if</span> <span class="ident">const_tick_count</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="macro">switch_delayed_lists</span><span class="macro">!</span>();
        } <span class="kw">else</span> {
            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
        }

        <span class="comment">/* See if this tick has made a timeout expire.  Tasks are stored in
        the	queue in the order of their wake time - meaning once one task
        has been found whose block time has not expired there is no need to
        look any further down the list. */</span>
        <span class="kw">if</span> <span class="ident">const_tick_count</span> <span class="op">&gt;=</span> <span class="macro">get_next_task_unblock_time</span><span class="macro">!</span>() {
            <span class="macro">trace</span><span class="macro">!</span>(<span class="string">&quot;UNBLOCKING!&quot;</span>);
            <span class="kw">loop</span> {
                <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">list_is_empty</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>) {
                    <span class="comment">/* The delayed list is empty.  Set xNextTaskUnblockTime
                    to the maximum possible value so it is extremely
                    unlikely that the
                    if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass
                    next time through. */</span>
                    <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">port</span>::<span class="ident">portMAX_DELAY</span>);
                    <span class="kw">break</span>;
                } <span class="kw">else</span> {
                    <span class="comment">/* The delayed list is not empty, get the value of the
                    item at the head of the delayed list.  This is the time
                    at which the task at the head of the delayed list must
                    be removed from the Blocked state. */</span>
                    <span class="kw">let</span> <span class="ident">delay_head_entry_owner</span> <span class="op">=</span> <span class="ident">list</span>::<span class="ident">get_owner_of_head_entry</span>(<span class="kw-2">&amp;</span><span class="ident">DELAYED_TASK_LIST</span>);
                    <span class="kw">let</span> <span class="ident">task_handle</span> <span class="op">=</span> <span class="ident">delay_head_entry_owner</span>;
                    <span class="kw">let</span> <span class="ident">state_list_item</span> <span class="op">=</span> <span class="ident">task_handle</span>.<span class="ident">get_state_list_item</span>();
                    <span class="kw">let</span> <span class="ident">event_list_item</span> <span class="op">=</span> <span class="ident">task_handle</span>.<span class="ident">get_event_list_item</span>();
                    <span class="kw">let</span> <span class="ident">item_value</span> <span class="op">=</span> <span class="ident">list</span>::<span class="ident">get_list_item_value</span>(<span class="kw-2">&amp;</span><span class="ident">state_list_item</span>);

                    <span class="kw">if</span> <span class="ident">const_tick_count</span> <span class="op">&lt;</span> <span class="ident">item_value</span> {
                        <span class="comment">/* It is not time to unblock this item yet, but the
                        item value is the time at which the task at the head
                        of the blocked list must be removed from the Blocked
                        state -	so record the item value in
                        xNextTaskUnblockTime. */</span>
                        <span class="macro">set_next_task_unblock_time</span><span class="macro">!</span>(<span class="ident">item_value</span>);
                        <span class="kw">break</span>;
                    } <span class="kw">else</span> {
                        <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                    }

                    <span class="comment">/* It is time to remove the item from the Blocked state. */</span>
                    <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">state_list_item</span>.<span class="ident">clone</span>());

                    <span class="comment">/* Is the task waiting on an event also?  If so remove
                    it from the event list. */</span>
                    <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">get_list_item_container</span>(<span class="kw-2">&amp;</span><span class="ident">event_list_item</span>).<span class="ident">is_some</span>() {
                        <span class="ident">list</span>::<span class="ident">list_remove</span>(<span class="ident">event_list_item</span>.<span class="ident">clone</span>());
                    }
                    <span class="comment">/* Place the unblocked task into the appropriate ready
                    list. */</span>
                    <span class="ident">task_handle</span>.<span class="ident">add_task_to_ready_list</span>().<span class="ident">unwrap</span>();

                    <span class="comment">/* A task being unblocked cannot cause an immediate
                    context switch if preemption is turned off. */</span>
                    {
                        <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>)]</span>
                        <span class="comment">/* Preemption is on, but a context switch should
                        only be performed if the unblocked task has a
                        priority that is equal to or higher than the
                        currently executing task. */</span>
                        <span class="kw">if</span> <span class="ident">task_handle</span>.<span class="ident">get_priority</span>() <span class="op">&gt;=</span> <span class="macro">get_current_task_priority</span><span class="macro">!</span>() {
                            <span class="ident">switch_required</span> <span class="op">=</span> <span class="bool-val">true</span>;
                        } <span class="kw">else</span> {
                            <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
                        }
                    }
                }
            }
        }

        <span class="comment">/* Tasks of equal priority to the currently running task will share
        processing time (time slice) if preemption is on, and the application
        writer has not explicitly turned time slicing off. */</span>
        {
            <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TIME_SLICING&quot;</span>))]</span>
            <span class="kw">let</span> <span class="ident">cur_task_pri</span> <span class="op">=</span> <span class="macro">get_current_task_priority</span><span class="macro">!</span>();

            <span class="kw">if</span> <span class="ident">list</span>::<span class="ident">current_list_length</span>(<span class="kw-2">&amp;</span><span class="ident">READY_TASK_LISTS</span>[<span class="ident">cur_task_pri</span> <span class="kw">as</span> <span class="ident">usize</span>]) <span class="op">&gt;</span> <span class="number">1</span> {
                <span class="ident">switch_required</span> <span class="op">=</span> <span class="bool-val">true</span>;
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        }

        {
            <span class="attribute">#![<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TICK_HOOK&quot;</span>)]</span>
            <span class="comment">/* Guard against the tick hook being called when the pended tick
            count is being unwound (when the scheduler is being unlocked). */</span>
            <span class="kw">if</span> <span class="macro">get_pended_ticks</span><span class="macro">!</span>() <span class="op">==</span> <span class="number">0</span> {
                <span class="comment">// vApplicationTickHook();</span>
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        }
    } <span class="kw">else</span> {
        <span class="macro">set_pended_ticks</span><span class="macro">!</span>(<span class="macro">get_pended_ticks</span><span class="macro">!</span>() <span class="op">+</span> <span class="number">1</span>);

        <span class="comment">/* The tick hook gets called at regular intervals, even if the
        scheduler is locked. */</span>
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TICK_HOOK&quot;</span>)]</span>
        <span class="ident">vApplicationTickHook</span>();

        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PREEMPTION&quot;</span>)]</span>
        {
            <span class="kw">if</span> <span class="macro">get_yield_pending</span><span class="macro">!</span>() {
                <span class="ident">switch_required</span> <span class="op">=</span> <span class="bool-val">true</span>;
            } <span class="kw">else</span> {
                <span class="macro">mtCOVERAGE_TEST_MARKER</span><span class="macro">!</span>();
            }
        }
    }
    <span class="ident">switch_required</span>
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(
    <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;INCLUDE_xTaskGetSchedulerState&quot;</span>,
    <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_TIMERS&quot;</span>
))]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">task_get_scheduler_state</span>() <span class="op">-&gt;</span> <span class="ident">SchedulerState</span> {
    <span class="comment">// These enums are defined at the top of this file.</span>
    <span class="kw">if</span> <span class="op">!</span><span class="macro">get_scheduler_running</span><span class="macro">!</span>() {
        <span class="ident">SchedulerState</span>::<span class="ident">NotStarted</span>
    } <span class="kw">else</span> {
        <span class="kw">if</span> <span class="macro">get_scheduler_suspended</span><span class="macro">!</span>() <span class="op">==</span> <span class="ident">pdFALSE</span> <span class="kw">as</span> <span class="ident">UBaseType</span> {
            <span class="ident">SchedulerState</span>::<span class="ident">Running</span>
        } <span class="kw">else</span> {
            <span class="ident">SchedulerState</span>::<span class="ident">Suspended</span>
        }
    }
}

<span class="comment">/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
they are only required when a port optimised method of task selection is
being used. */</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PORT_OPTIMISED_TASK_SELECTION&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskRESET_READY_PRIORITY</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">uxPriority</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {};
}

<span class="comment">/* uxTopReadyPriority holds the priority of the highest priority ready
state task. */</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;configUSE_PORT_OPTIMISED_TASK_SELECTION&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">taskRECORD_READY_PRIORITY</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">uxPriority</span>: <span class="ident">expr</span>) <span class="op">=&gt;</span> {
        <span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">uxPriority</span> <span class="op">&gt;</span> <span class="macro">get_top_ready_priority</span><span class="macro">!</span>() {
            <span class="macro">set_top_ready_priority</span><span class="macro">!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">uxPriority</span>);
        }
    };
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rust_freertos";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>