\documentclass[12pt, a4paper]{article}

% Preamble
\usepackage{xeCJK}
\usepackage{newunicodechar}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[margin=1in]{geometry}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{nasm/lang}
\usepackage{nasm/style}
\usepackage{c/style}
\usepackage{go/lang}
\usepackage{go/style}
\usepackage{reil/lang}
\usepackage{llvm/lang}
\usepackage{diff/lang}
\usepackage{diff/style}
\usepackage{dot/lang}
\usepackage{dot/style}
\usepackage{float}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{listings}
\lstset{basicstyle={\normalfont\sffamily},breaklines}

\title{code}
\author{Rust-FreeRTOS Team}
\date{March 28, 2019}
\begin{document}
	\section{FreeRTOS调研}
	我们对FreeRTOS的系统结构进行了一系列的调研之后，整理了以下重要的API。
	\subsection{FreeRTOS v10.2.0 task.c 中任务创建API}
	\subsubsection {xTaskCreate}

	\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskCreate(TaskFunction_t pvTaskCode,
                       const char * const pcName,
                       configSTACK_DEPTH_TYPE usStackDepth,
                       void *pvParameters,
                       UBaseType_t uxPriority,
                       TaskHandle_t *pvCreatedTask);
\end{lstlisting}

创建一个任务，并且自动为其分配\textbf{栈空间}和\textbf{数据空间}。

\subsubsection {xTaskCreateStatic}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
				const char * const pcName,
				uint32_t ulStackDepth,
				void *pvParameters,
				UBaseType_t uxPriority,
				StackType_t *pxStackBuffer,
				StaticTask_t *pxTaskBuffer );
\end{lstlisting}
创建一个任务，此时需要程序员来提供一个\textbf{栈空间}和\textbf{数据空间}的地址。

\subsubsection {xTaskCreateRestricted}
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskCreateRestricted(TaskParameters_t  *pxTaskDefinition,
				TaskHandle_t *pxCreatedTask );
\end{lstlisting}

创建一个任务，此时需要程序员手动提供一个\textbf{栈空间}地址。

\subsubsection {xTaskCreateRestrictedStatic}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
 BaseType_t xTaskCreateRestrictedStatic( 
 			TaskParameters_t *pxTaskDefinition, 
 			TaskHandle_t *pxCreatedTask );
\end{lstlisting}

创建一个任务，需要程序员手动提供\textbf{栈空间}地址。\textbf{数据空间}会被自动地动态分配。

\subsubsection {vTaskAllocateMPURegions}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskAllocateMPURegions( TaskHandle_t xTask, 
	 const MemoryRegion_t * const pxRegions );
\end{lstlisting}

用来为\textbf{restricted task}分配内存空间。

\subsubsection {vTaskDelete}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskDelete( TaskHandle_t xTask )；
\end{lstlisting}

删除一个任务。


\subsection {FreeRTOS v10.2.0 task.c 中任务控制API}

\subsubsection {vTaskDelay}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskDelay( const TickType_t xTicksToDelay );
\end{lstlisting}

以给定参数来延迟任务。

\subsubsection {vTaskDelayUntil}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, 
		      const TickType_t xTimeIncrement );
\end{lstlisting}

指定某个确定的时间点来解除阻塞。

\subsubsection {xTaskAbortDelay}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskAbortDelay( TaskHandle_t xTask );
\end{lstlisting}

让任务从跳出阻塞状态回到它原来被调用的地方。

\subsubsection {uxTaskPriorityGet}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
\end{lstlisting}

获得任务的优先级。

\subsubsection {eTaskGetState}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
eTaskState eTaskGetState( TaskHandle_t xTask );
\end{lstlisting}

获取任务的状态码，是一个枚举类型。

\subsubsection {vTaskGetInfo}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskGetInfo( TaskHandle_t xTask, 
		   TaskStatus_t *pxTaskStatus,
		   BaseType_t xGetFreeStackSpace,
		   eTaskState eState );
\end{lstlisting}

获取任务的信息。

\subsubsection {vTaskPrioritySet}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskPrioritySet( TaskHandle_t xTask,
		       UBaseType_t uxNewPriority );
\end{lstlisting}

设置任务的优先级。

\subsubsection {vTaskSuspend}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskSuspend( TaskHandle_t xTaskToSuspend );
\end{lstlisting}

挂起任务。

\subsubsection {vTaskResume}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskResume( TaskHandle_t xTaskToResume );
\end{lstlisting}

继续执行被挂起的任务。

\subsection {FreeRTOS v10.2.0 task.c 中程序调度API}

\subsubsection {vTaskStartScheduler}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskStartScheduler( void );
\end{lstlisting}

启动任务调度程序。

\subsubsection {vTaskEndScheduler}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskEndScheduler( void );
\end{lstlisting}

停止任务调度程序，在处理完后，又重新从\textbf{vTaskStartScheduler}开始。

\subsubsection {vTaskSuspendAll}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vTaskSuspendAll( void );
\end{lstlisting}

在不终止中断的情况下挂起调度程序。

\subsubsection {xTaskResumeAll}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskResumeAll( void );
\end{lstlisting}

继续执行被挂起的调度程序。

\subsubsection {xTaskGetTickCount}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
TickType_t xTaskGetTickCount( void );
\end{lstlisting}

获取从`vTaskStartScheduler`被调用到现在的毫秒数。

\subsubsection {uxTaskGetNumberOfTasks}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
uint16_t uxTaskGetNumberOfTasks( void );
\end{lstlisting}

返回内核正在管理的任务的子总数目。

\subsubsection {pcTaskGetName}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
char *pcTaskGetName( TaskHandle_t xTaskToQuery );
\end{lstlisting}

返回任务的名字。

\subsubsection {xTaskGetHandle}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );
\end{lstlisting}

返回任务的句柄。

\subsubsection {uxTaskGetStackHighWaterMark}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
\end{lstlisting}

返回栈使用空间最大的那次数值。

\subsubsection {xTaskCallApplicationTaskHook}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, 
                                         void *pvParameter );
\end{lstlisting}

执行相应的钩子函数。

\subsubsection {xTaskGetIdleTaskHandle}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
TaskHandle_t xTaskGetIdleTaskHandle( void )；
\end{lstlisting}

返回空闲任务的句柄。

\subsubsection {xTaskGetIdleRunTimeCounter}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
TickType_t xTaskGetIdleRunTimeCounter( void );
\end{lstlisting}

返回空闲任务的运行时间。

\subsubsection {xTaskNotify}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, 
			uint32_t ulValue, 
			eNotifyAction eAction );
\end{lstlisting}

发送广播。

\subsubsection {xTaskNotifyWait}
\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, 
			    uint32_t ulBitsToClearOnExit, 
                            uint32_t *pulNotificationValue, 
                            TickType_t xTicksToWait );
\end{lstlisting}

等待广播。



\subsection {queue.c文件中的重要函数}

\subsubsection {xQueueCreate}

创建一个队列。

\subsubsection {xQueueCreateStatic}

使用静态方式创建一个队列。

\subsubsection {xQueueSendToToFront}

将一个元素送到队首。

\subsubsection {xQueueSendToBack}

将一个元素送到队尾。

\subsubsection {xQueueSend}

插入一个元素到队列中。

\subsubsection {xQueueOverwrite}

插入一个元素到队列中，如果队列已经满，则覆盖。

\subsubsection {xQueueGenericSend}

和`xQueueSend`效果相同，但是是推荐的API。

\subsubsection {xQueuePeek}

获取一个队列中中的元素但是不删除其在队列中的位置。

\subsubsection {xQueueReceive}

获取一个队列中的元素，成功访问后就删除该元素在队列中的位置。

\subsubsection {uxQueueMessagesWaiting}

返回储存在队列中信息的数目。

\subsubsection {uxQueueSpacesAvailable}

返回队列中的可用空间。

\subsubsection {vQueueDelete}

删除队列。

> 上面的函数定义是为了在任务间传输数据，下面的函数用于`co-routines`（联合任务）

\subsection {list.c 中的主要函数}

\subsubsection {vListInitialise}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vListInitialise( List_t * const pxList );
\end{lstlisting}

列表的初始化。

\subsubsection {vListInitialiseItem}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vListInitialiseItem( ListItem_t * const pxItem );
\end{lstlisting}

列表项的初始化。

\subsubsection {vListInsert}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vListInsert( List_t * const pxList, 
                  ListItem_t * const pxNewListItem );
\end{lstlisting}

列表项插入。

\subsubsection {vListInsertEnd}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem );
\end{lstlisting}

列表项插入到最后。

\subsubsection {uxListRemove}

\begin{lstlisting}[language={[ANSI]C},keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20}]
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove );
\end{lstlisting}

从列表中移除一个列表项。
\end{document}
